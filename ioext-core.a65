
; the majority of the calls have the device number
; already in AC in normalized form, i.e. in the 
; range starting from 0 up to 3

	.(
	; jump table for companion
&IO_RESET	jmp do_reset
&IO_IRQ		jmp do_irq
&IO_OPEN	jmp do_open
&IO_CLOSE	jmp do_close
&IO_CHKOUT	jmp do_chkout
&IO_CHKIN	jmp do_chkin
&IO_CLRCH_OUT 	jmp do_clrch_out
&IO_CLRCH_IN	jmp do_clrch_in
&IO_OUT		jmp j_out
&IO_IN		jmp j_in
	; jump table for boot code
&BOOT_ENABLE	jmp boot_en
&BOOT_GET	jmp boot_get
&BOOT_PUT	jmp boot_put

	;--------------------------------
	; boot code.
	; 
	; when BOOT_ENABLE is called with C=1
	; then enable rx from both RS232 channels
	; When called with C=0 disable it
	;
	; when BOOT_ENABLE is set, then
	; BOOT_GET and BOOT_PUT can be used
	; to receive and send data

	.(

&boot_en .(
	ror boot_st

	bit boot_st
	bmi on
	; switch off
	jmp uart_res

on	lda #15		; 19200 baud
	sta IOEXT_FILENAME
	lda #0
	sta IOEXT_FILENAME+1
	jsr uart1_open
	jsr uart2_open
	lda #0
	sta actdev	; not decided yet
	rts
	.)

&boot_get .(
	bit boot_st
	bpl noboot
	ldx actdev
	beq both

	dex
	bne secnd

	jmp uart1_rx
secnd	jmp uart2_rx

both	
	jsr uart1_rx
	bcc ok1
	jsr uart2_rx
	bcs ret
	ldx #2
	.byt $2c
ok1	ldx #1
	stx actdev
ret	rts
	.)

&boot_put .(
	ldx actdev
	beq noboot
	; simple petscii to ascii conversion
	cmp #13
	bne conv
	jsr conv
	lda #10
	ldx actdev

conv	jsr petscii2ascii

retry	pha
	dex
	beq first
	jsr uart2_tx
	bcc done
	bcs check
first
	jsr uart1_tx
	bcc done

check	cpy #E_FULL
	bne done
	pla
	ldx actdev
	bra retry

done	pla
	rts
	.)

noboot	sec
	ldy #E_NODEV
	rts

petscii2ascii .(
	cmp #64
	bcc ok
	cmp #96
	bcs ok
	adc #32
ok	and #$7f
	rts
	.)

ascii2petscii .(
	cmp #64
	bcc ok
	cmp #96
	bcc add
	adc #128-32-2
add	adc #128
ok	rts
	.)


&actdev	.byt 0	
&boot_st
	.byt 0	
	.)

	;--------------------------------
	; standard OS calls
do_reset .(
	jsr do_clrch_out
	jsr do_clrch_in
	jsr uart_res
	ldx actdev
	beq no_act
	dex
	beq first
	jmp uart2_on
first	jmp uart1_on
no_act	rts
	.)

do_irq	.(
	jmp uart_irq
	.)

do_open .(
	asl
	tax
	lda v_open_list+1,x
	clc
	beq v_rts2
	sta v+1
	lda v_open_list,x
	sta v
	jsr do_v	; preserve C till RTS
	phx
	ply		; move status into Y
v_rts2	rts
do_v	jmp (v)
	.)

	; close channels
do_close .(
	asl
	tax
	lda v_close_list+1,x
	beq v_rts
	sta v+1
	lda v_close_list,x
	sta v
	jmp (v)
	.)
	
	;----------------------------
	; set the output channel
	;
	; assumes that the kernel has
	; already called clrch
do_chkout
	asl
	tax
	lda v_ckout_list+1,x
	clc
	beq no_ckout
	sta v_out_c+1
	lda v_ckout_list,x
	sta v_out_c
	phx
	sec		; set output
	jsr j_out_c	; preserve C until RTS!
	phx
	ply		; move status to Y
	plx
no_ckout
	lda v_out_list+1,x
	sta v_out+1
	lda v_out_list,x
	sta v_out
	rts

	;----------------------------
	; set the input
	; 
	; assumes that the kernel 
	; has already called clrch
do_chkin .(
	asl
	tax
	lda v_ckin_list+1,x
	clc
	beq no_ckin
	sta v_in_c+1
	lda v_ckin_list,x
	sta v_in_c
	phx
	sec		; set input
	jsr j_in_c	; preserver C until RTS
	phx
	ply		; transfer error to Y
	plx
no_ckin
	lda v_in_list+1,x
	sta v_in+1
	lda v_in_list,x
	sta v_in
	rts
	.)

	;----------------------------
	; clear output
do_clrch_out .(
	clc		; clrch out
	jsr j_out_c	; preserve C, X->Y
	phx
	ply
	lda #<v_rts
	sta v_out
	lda #>v_rts
	sta v_out+1
	rts
	.)

	; clear input
do_clrch_in .(
	clc
	jsr j_in_c	; clrch in
	phx
	ply
	lda #<v_rtsc1
	sta v_in
	lda #>v_rtsc1
	sta v_in+1
	rts
	.)

	;----------------------------
v_rtsc1
	sec
v_rts
	rts

	; out vector is set by chkout
j_out
	jmp (v_out)

	; in vector is set by chkin
j_in 	jmp (v_in)

j_in_c 	jmp (v_in_c)
j_out_c	jmp (v_out_c)

v	.word 0
v_out	.word v_rts	; ouput char
v_out_c	.word v_rts	; control for output
v_in	.word v_rts	; input char
v_in_c	.word v_rts	; control for input

v_ckout_list
	.word i2c_ckout, 0, 0, 0
v_ckin_list
	.word i2c_ckin, 0, 0, 0
v_out_list
	.word i2c_send, uart1_tx, uart2_tx, v_rts
v_in_list
	.word i2c_recv, uart1_rx, uart2_rx, v_rts
v_close_list
	.word i2c_close, uart1_off, uart2_off, 0
v_open_list
	.word i2c_open, uart1_open, uart2_open, 0

#include "ioext-stream.i65"
#include "ioext-ser.a65"
#include "ioext-i2c.a65"

	.)

