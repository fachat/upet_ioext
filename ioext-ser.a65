
#if 0

/*
 * This is an UART 16550A serial line driver 
 * It uses the hardware installed in the UltiPET. The two
 * 16550A are mapped at $e818 and $e828, above the both PIAs.
 *
 * The 16550 is not really an easy chip, but it has 16 byte
 * input and output FIFO buffers, which allows much higher
 * interrupt latencies.
 */

	.(
UART1		=$e818
UART2		=$e828

UARTBASE	=UART1
UARTDIFF	=UART2-UART1

#ifdef UARTXTAL
#define	XTALMULT	UARTXTAL
#else
#define	XTALMULT	1
#endif

#include "uart16550.i65"


	; do the reset routine for the two UARTs
uart_res
	jmp devini

	; do the interrupt routine for the two UARTs
uart_irq 
	jmp devirq
	; 
	
/* 
 * 16550 divisor values for BAUD rates ?, 50, 75, 110, 134.5, 150, 
 * 300, 600, 1200, 1800, 2400, 3600, 4800, 7200, 9600, 19200
 */
divisor	.word 	-1, 2304 * XTALMULT, 1536 * XTALMULT, 1047 * XTALMULT
	.word   857 * XTALMULT, 768 * XTALMULT, 384 * XTALMULT
	.word   192 * XTALMULT, 96 * XTALMULT
	.word	64 * XTALMULT, 48 * XTALMULT, 32 * XTALMULT
	.word   24 * XTALMULT, 16 * XTALMULT, 12 * XTALMULT
	.word   6 * XTALMULT


	; -----------------------------------------
u_first	=*

u1_hw	.byt 0			; if bit 7 set, then hw is ready
u1_st	.byt 0			; if bit 7 set, then rx, bit 6 set then tx
				; read and write pointer indexes into 
				; transfer buffers
u1_txwp	.byt 0			; tx, write from OS
u1_txrp	.byt 0			; tx, read from int
u1_rxwp	.byt 0			; rx write from int
u1_rxrp	.byt 0			; rx, read from OS

				; pad structure so that attributes
				; can be accessed with UARTDIFF index
	.dsb u1_hw+UARTDIFF-*, 0	 

u2_hw	.byt 0			; if bit 7 set then hw is ready
u2_st	.byt 0			; if bit 7 set, then rx, bit 6 set then tx
				; read and write pointer indexes into 
				; transfer buffers
u2_txwp	.byt 0			; tx, write from OS
u2_txrp	.byt 0			; tx, read from int
u2_rxwp	.byt 0			; rx write from int
u2_rxrp	.byt 0			; rx, read from OS

u_last	=*			; end pointer for fill
u_len	=u_last-u_first

	.(
	.text
&devini 
	lda #0
	ldx #u_len-1
:	sta u_first,x
	dex
	bpl :-

	ldx #0
	jsr res
	ror u1_hw	; bit 7: 0=ok
	ldx #UARTDIFF
	jsr res
	ror u2_hw	; bit 7: 0=ok
	rts
res
	lda UARTBASE+UART_MCR,x
	pha

	lda #$10
	sta UARTBASE+UART_MCR,x
	lda UARTBASE+UART_MSR,x
	and #$f0
	bne nodev

	lda #$1f
	sta UARTBASE+UART_MCR,x
	lda UARTBASE+UART_MSR,x
	and #$f0
	cmp #$f0
	bne nodev

	pla
	sta UARTBASE+UART_MCR,x
	lda UARTBASE+UART_SCR,x
	pha

	lda #%10101010
	sta UARTBASE+UART_SCR,x
	cmp UARTBASE+UART_SCR,x
	bne dev8250
	lsr
	sta UARTBASE+UART_SCR,x
	cmp UARTBASE+UART_SCR,x
	bne dev8250

	lda #1
	sta UARTBASE+UART_FCR,x
	lda UARTBASE+UART_IIR,x

	pha
	lda #0
	sta UARTBASE+UART_FCR,x
	pla

	asl
	bcc dev16450
	asl
	bcc dev16550

	pla
	sta UARTBASE+UART_SCR,x

	; else dev16550A; currently only this one is supported

	lda #%10000000
	sta UARTBASE+UART_LCR,x
	ldy #14*2			; 9600 BAUD
	lda divisor,y
	sta UARTBASE+UART_DLL,x
	lda divisor+1,y
	sta UARTBASE+UART_DLH,x
	lda #%00000011			; 8N1
	sta UARTBASE+UART_LCR,x
 
 	lda #7				; no FIFO enable and clear FIFOs, 
	sta UARTBASE+UART_FCR,x		; trigger at 1 byte
	lda #0
	sta UARTBASE+UART_IER,x		; polled mode (so far) 
	lda UARTBASE+UART_MCR,x
	and #%00001100			; keep OUT1, OUT2 values
	sta UARTBASE+UART_MCR,x		; reset DTR, RTS

        sec
        rts

nodev					; no UART at all
dev8250					; no Scratchpad, no FIFO
dev16450				; scratchpad, no FIFO
dev16550				; FIFO bug
	pla
	clc
	rts
        .)
  
/*****************************************************************/

	.(
&devirq bit u1_hw
	bpl no_u1
	ldx #0
	jsr irq
no_u1	bit u2_hw
	bpl no_u2
	ldx #UARTDIFF
	jsr irq
no_u2	rts

	; interrupt for one UART
irq 
	lda UARTBASE+UART_IIR,x
	lsr
	bcs irqe		; no rx irq

	;-----------------------------------------------

intr
	; modem
	lda UARTBASE + UART_MSR,x	; clear modem int
	; line status
	lda UARTBASE + UART_LSR,x	; line status (TODO eval)
	; rx
rxl	lda UARTBASE + UART_LSR,x
	and #1
	beq tx
	; received a byte (or more)
	jsr rx2
	; check again
	jmp rxl

	; tx
tx	; is done in irq end handling	

irqe
	; check if we have data to send,
	; even if previous THR empty ints have been
	; cleared already
	lda UARTBASE+UART_LSR,x
	and #$40
	beq nbyt
	jsr tx2
	; check rx/tx status
	jsr status
nbyt
	rts

	;-----------------------------------------------

rx2	.(
	lda UARTBASE+UART_RXTX,x
	tay

	lda u1_st,x
	bpl rx2end

	; rx'd byte in YR
	txa
	beq rx_u1
rx_u2	tya
	ldy u2_rxwp,x
	sta (u2p),y
	inc u2_rxwp,x
	
&status ldx outstr
	bit status
	bpl rx2end
        lda #SC_STAT
        jsr STRCMD
        bcc rx2end
test
        cmp #E_NUL
        bne tstwater
        jmp rxoff
tstwater  
	cmp #E_SEMPTY
        beq wl
        tax
        lda status
        and #1
        bne wh
        txa
        cmp #E_SHWM
        beq wh
        cmp #E_SFULL
        bne twl
wh      ldx #0  
	jmp rtshi
twl     cmp #E_SLWM
        bne rx2end
wl      ldx #0  
	jmp rtslo
	.)

	;-----------------------------------------------

tx2 	.(
	bit status
        bvc txrt		; reading IIR should clear this line

	lda UART+UART_MSR
	and #%00110000
	cmp #%00110000		; cts or dsr inactive
	bne txrt

	ldy #15			
txloop
        ldx instr		; send new data byte
        jsr GETC
        bcs test2
        sta UART+UART_RXTX
	dey
	bne txloop		; fill up FIFO
        bcc txrt

test2   cmp #E_EOF
        bne txrt
        jmp txoff
txrt	rts
	.)

          .)

/*****************************************************************/

dtrhi
	lda UART+UART_MCR
	and #%11111110
	sta UART+UART_MCR
	lda #0
	sta UART+UART_IER
	rts

dtrlo
	lda UART+UART_MCR
	ora #%00000001
	sta UART+UART_MCR
	lda #3
	sta UART+UART_IER
	rts

rtshi
	lda UART+UART_MCR
	and #%11111101
	sta UART+UART_MCR
	lda status,x
	ora #%0010000
	sta status,x
	rts

rtslo
	lda UART+UART_MCR
	ora #%00000010
	sta UART+UART_MCR
	lda status,x
	and #%11011111
	sta status,x
	rts

/*****************************************************************/

others    cmp #DC_GS		; set stream to get data from
          bne o1
          lda status,x
          and #DC_SW_TX
          bne devonx
          tya
          sta instr,x
          jmp ok
devonx    jmp devon
o1        cmp #DC_PS		; set stream to put data to
          bne o2
          lda status,x
          and #DC_SW_RX
          bne devonx
          tya
          sta outstr,x
okx       jmp ok
o2        cmp #DC_RX_ON		; switch receiver on
          bne o3
	; lda #3
	; sta brkkey
	jsr rtslo
	jsr dtrlo
          lda #DC_SW_RX
          bne o2a
o3        cmp #DC_TX_ON		; switch sender on
          bne o4
	jsr dtrlo
          lda #DC_SW_TX
o2a       ora status,x
          sta status,x
          bne okx
o4        cmp #DC_RX_OFF	; switch receiver off, send eof to stream
          bne o5
rxoff     ldx dev
          lda status,x
          and #DC_SW_RX
          beq devoffx
	jsr rtshi
          lda outstr,x
          tax
          lda #SC_EOF
          jsr STRCMD
          ldx dev
          lda status,x
          and #255-DC_SW_RX
          sta status,x
	  jmp checkdtr

devoffx   jmp  devoff

o5        cmp #DC_TX_OFF	; switch sender off, send nul to stream
          bne o6
txoff     ldx dev
          lda status,x
          and #DC_SW_TX
          beq devoffx
          lda instr,x
          tax
          lda #SC_NUL
          jsr STRCMD
          ldx dev
          lda status,x
          and #255-DC_SW_TX
          sta status,x
checkdtr
	and #DC_SW_TX+DC_SW_RX
	bne active
	jsr dtrhi
active 	jmp ok

o6        cmp #DC_HS		; set handshake -- currently ignored (TODO)
          bne o6a
          lda status,x
          and #255-1
          sta status,x
          tya
          and #1
          ora status,x
          sta status,x
          jmp ok

o6a       cmp #DC_SPD		; set speed
          bne o7
          tya
          and #%00001111
	  asl
          tax
	  beq ok

	lda UART+UART_LCR
	ora #$80
	sta UART+UART_LCR
  	lda divisor,x
	sta UART+UART_DLL
	lda divisor+1,x
	sta UART+UART_DLH
	lda UART+UART_LCR
	and #$7f
	sta UART+UART_LCR

          jmp ok

o7        cmp #DC_ST		; get status...
          beq ok 
          cmp #DC_EXIT		; disable everything
          bne o8		; onotimp
          jsr rxoff
          jsr txoff
          ldx dev 
          lda status,x
          ora #2
          sta status,x
	  bne ok
o8
	  cmp #DC_BRKKEY
	  bne onotimp
          lda brkkey
	  sty brkkey
	  tay
	  ; jmp ok

ok        lda #E_OK
          .byt $2c
devon     lda #E_DON
          .byt $2c
devoff    lda #E_DOFF
          .byt $2c
onotimp   lda #E_NOTIMP
          cmp #1
          rts

#undef UART
#undef XTALMULT

devend2   .)

#endif
