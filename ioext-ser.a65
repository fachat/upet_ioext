
#if 1

/*
 * This is an UART 16550A serial line driver 
 * It uses the hardware installed in the UltiPET. The two
 * 16550A are mapped at $e818 and $e828, above the both PIAs.
 *
 * The 16550 is not really an easy chip, but it has 16 byte
 * input and output FIFO buffers, which allows much higher
 * interrupt latencies.
 */

	.(
UART1		=$e818
UART2		=$e828

UARTBASE	=UART1
UARTDIFF	=UART2-UART1

#ifdef UARTXTAL
#define	XTALMULT	UARTXTAL
#else
#define	XTALMULT	1
#endif

#include "uart16550.i65"


	; do the reset routine for the two UARTs
&uart_res
	jmp devini

	; do the interrupt routine for the two UARTs
&uart_irq 
	jmp devirq

	;---------------------------------
	; setup the RS232
	; 
	; uses the first two chars of the filename as config bytes
	; as taken from the C64
	;
	; 1st byte
	;	b7	0	1 stop bit
	;		1	2 stop bits
	;
	;	b5,6=	0	8 bit
	;		32	7 bit
	;		64	6 bit
	;		96	5 bit
	;
	;	b3-0=	0	custom baud rata
	;		1	50 baud
	;		2	75 baud
	;		3	110 baud
	;		4	134.5 baud
	;		5	150 baud
	;		6	300 baud
	;		7	600 baud
	;		8	1200 baud
	;		9	1800 baud
	;		10	2400 baud
	;		11	3600 baud
	;		12	4800 baud
	;		13	7200 baud
	;		14	9600 baud
	;		15	19200 baud
	;
	; 2nd byte
	;	b7,6,5	x,x,0	no parity
	;		0,0,1	odd parity
	;		0,1,0	even parity
	;		1,0,1	parity bit always 1
	;		1,1,1	parity bit always 0
	;
	;	b4	0	full duplex
	;		1	half duplex
	;
	;	b1,2,3	-
	;
	;	b0	0	3-wire handshake (i.e. no RTS/CTS)
	;		1	X-wire handshake
	;
&uart1_open
	ldx #0
	.byt $2c
&uart2_open
	ldx #UARTDIFF
	; check first two chars of the filename
	lda IOEXT_FILENAME
	and #$0f
	jsr ser_speed
	jmp ser_on

	;---------------------------------
	; transmit buffer

	; get a char from receive buffer in OS
	; x is 0/UARTDIFF, returns char in A when C=0; C=1 -> no char
&uart1_rx
	ldx #0
	.byt $2c
&uart2_rx
	ldx #UARTDIFF
stream_receive .(
	lda u1_rxrp,x
	cmp u1_rxwp,x
	beq empty
	tay
	txa
	bne u2_get
	lda u1_rxbuf,y
	bra ux_end
u2_get	lda u2_rxbuf,y
ux_end	iny
	pha
	tya
	sta u1_rxrp,x
	pla
	clc
	rts
empty	ldy #E_EMPTY
	sec
	rts
	.)

	;-----------------------------------------
	; write a char to receive buffer from interrupt
	; x is/UARTDIFF, a is byte to send
	; returns c=0 or c=1 (error)
stream_put .(
	pha
	lda u1_rxwp,x
	tay
	clc
	adc #1
	cmp u1_rxrp,x
	beq full
	pla
	cpx #0
	bne u2_put
	sta u1_rxbuf,y
	beq ux_end
u2_put	sta u2_rxbuf,y
ux_end	iny
	tya
	sta u1_rxwp,x
	clc
	rts
full	pla
	lda #E_SHWM
	sec
	rts
	.)

	;---------------------------------
	; transmit buffer

	; get a char from send buffer in interrupt
	; x is 0/UARTDIFF, returns char in A when C=0; C=1 -> no char
stream_get .(
	lda u1_txrp,x
	cmp u1_txwp,x
	beq empty
	tay
	txa
	bne u2_get
	lda u1_txbuf,y
	bra ux_end
u2_get	lda u2_txbuf,y
ux_end	pha
	iny
	tya
	sta u1_txrp,x
	pla
	clc
	rts
empty	sec
	rts
	.)

	;-----------------------------------------
	; write a char to send buffer from OS
	; x is/UARTDIFF, a is byte to send
	; returns c=0 or c=1 (error)
&uart1_tx
	ldx #0
	.byt $2c
&uart2_tx
	ldx #UARTDIFF
stream_send .(
	pha
	lda u1_txwp,x
	tay
	clc
	adc #1
	cmp u1_txrp,x
	beq full
	pla
	cpx #0
	bne u2_put
	sta u1_txbuf,y
	bne ux_end
u2_put	sta u2_txbuf,y
ux_end	iny
	tya
	sta u1_txwp,x
	clc
	rts
full	pla
	ldy #E_FULL
	sec
	rts
	.)

	.(
	.text
&devini 
	lda #0
	ldx #u_len-1
:	sta u_first,x
	dex
	bpl :-

	ldx #0
	jsr res
	ror u1_hw	; bit 7: 0=ok
	ldx #UARTDIFF
	jsr res
	ror u2_hw	; bit 7: 0=ok
	sec
	rts
res
	lda UARTBASE+UART_MCR,x
	pha

	lda #$10
	sta UARTBASE+UART_MCR,x
	lda UARTBASE+UART_MSR,x
	and #$f0
	bne nodev

	lda #$1f
	sta UARTBASE+UART_MCR,x
	lda UARTBASE+UART_MSR,x
	and #$f0
	cmp #$f0
	bne nodev

	pla
	sta UARTBASE+UART_MCR,x
	lda UARTBASE+UART_SCR,x
	pha

	lda #%10101010
	sta UARTBASE+UART_SCR,x
	cmp UARTBASE+UART_SCR,x
	bne dev8250
	lsr
	sta UARTBASE+UART_SCR,x
	cmp UARTBASE+UART_SCR,x
	bne dev8250

	lda #1
	sta UARTBASE+UART_FCR,x
	lda UARTBASE+UART_IIR,x

	pha
	lda #0
	sta UARTBASE+UART_FCR,x
	pla

	asl
	bcc dev16450
	asl
	bcc dev16550

	pla
	sta UARTBASE+UART_SCR,x

	; else dev16550A; currently only this one is supported

	lda #%10000000
	sta UARTBASE+UART_LCR,x
	ldy #14*2			; 9600 BAUD
	lda divisor,y
	sta UARTBASE+UART_DLL,x
	lda divisor+1,y
	sta UARTBASE+UART_DLH,x
	lda #0
	sta UARTBASE+UART_PSD,x
	lda #%00000011			; 8N1
	sta UARTBASE+UART_LCR,x
 
 	lda #7				; no FIFO enable and clear FIFOs, 
	sta UARTBASE+UART_FCR,x		; trigger at 1 byte
	lda #0
	sta UARTBASE+UART_IER,x		; polled mode (so far) 
	lda UARTBASE+UART_MCR,x
	and #%00001100			; keep OUT1, OUT2 values
	sta UARTBASE+UART_MCR,x		; reset DTR, RTS
        sec
        rts

nodev					; no UART at all
dev8250					; no Scratchpad, no FIFO
dev16450				; scratchpad, no FIFO
dev16550				; FIFO bug
	pla
	clc
	rts
        .)
  
/*****************************************************************/

	.(
&devirq bit u1_hw
	bpl no_u1
	ldx #0
	jsr irq
no_u1	bit u2_hw
	bpl no_u2
	ldx #UARTDIFF
	jsr irq
no_u2	rts

	; interrupt for one UART
irq
	lda UARTBASE+UART_IIR,x
	lsr
	bcs irqe		; no rx irq

	;-----------------------------------------------

intr
	; modem
	lda UARTBASE + UART_MSR,x	; clear modem int
	; line status
	lda UARTBASE + UART_LSR,x	; line status (TODO eval)
	; rx
rxl	lda UARTBASE + UART_LSR,x
	and #1
	beq tx
	; received a byte (or more)
	jsr rx2
	; check again
	jmp rxl

	; tx
tx	; is done in irq end handling	

irqe
	; check if we have data to send,
	; even if previous THR empty ints have been
	; cleared already
	lda UARTBASE+UART_LSR,x
	and #$40
	beq nbyt
	jsr tx2
nbyt
	rts

	;-----------------------------------------------

rx2	.(
	lda UARTBASE+UART_RXTX,x
	tay
	lda u1_st,x
	bpl rx2end
	tya
	; char is in a
	; x is 0 or UARTDIFF
	jsr stream_put
	bcc rx2end

tstwater  
        cmp #E_SHWM
        bne twl
wh     	jmp rtshi
twl     cmp #E_SLWM
        bne rx2end
wl      jmp rtslo

rx2end	rts
	.)

	;-----------------------------------------------

tx2 	.(
	lda u1_st,x
	and #$40
        beq txrt		; reading IIR should clear this line
	lda UARTBASE + UART_MSR,x
	and #%00110000
	cmp #%00110000		; cts or dsr inactive
	bne txrt

	ldy #15			
txloop
        jsr stream_get
        bcs test2
        sta UARTBASE + UART_RXTX,x
	dey
	bne txloop		; fill up FIFO
        bcc txrt
test2
txrt	rts
	.)

          .)

/*****************************************************************/

dtrhi
	lda UARTBASE + UART_MCR,x
	and #%11111110
	sta UARTBASE + UART_MCR,x
	lda #0
	sta UARTBASE + UART_IER,x
	rts

dtrlo
	lda UARTBASE + UART_MCR,x
	ora #%00000001
	sta UARTBASE + UART_MCR,x
	;lda #3
	lda #1
	sta UARTBASE + UART_IER,x
	rts

rtshi
	lda UARTBASE + UART_MCR,x
	and #%11111101
	sta UARTBASE + UART_MCR,x
	lda u1_st,x
	ora #%0010000
	sta u1_st,x
	rts

rtslo
	lda UARTBASE + UART_MCR,x
	ora #%00000010
	sta UARTBASE + UART_MCR,x
	lda u1_st,x
	and #%11011111
	sta u1_st,x
	rts

/*****************************************************************/

&uart1_on
	ldx #0
	.byt $2c
&uart2_on
	ldx #UARTDIFF
ser_on	jsr rtslo
	jsr dtrlo
	lda u1_st,x
	ora #%11000000
	sta u1_st,x
	rts

&uart1_off
	ldx #0
	.byt $2c
&uart2_off
	ldx #UARTDIFF
ser_off	jsr rtshi
	jsr dtrhi
	lda u1_st,x
	and #%00111111
	sta u1_st,x
	rts

; y has index in divisor table
ser_speed
	asl
	tay
	lda UARTBASE + UART_LCR,x
	ora #$80
	sta UARTBASE + UART_LCR,x
  	lda divisor,y
	sta UARTBASE + UART_DLL,x
	lda divisor+1,y
	sta UARTBASE + UART_DLH,x
	lda #0
	sta UARTBASE + UART_PSD,x
	lda UARTBASE + UART_LCR,x
	and #$7f
	sta UARTBASE + UART_LCR,x
	rts

	
/* 
 * 16550 divisor values for BAUD rates ?, 50, 75, 110, 134.5, 150, 
 * 300, 600, 1200, 1800, 2400, 3600, 4800, 7200, 9600, 19200
 */
divisor	.word 	-1, 2304 * XTALMULT, 1536 * XTALMULT, 1047 * XTALMULT
	.word   857 * XTALMULT, 768 * XTALMULT, 384 * XTALMULT
	.word   192 * XTALMULT, 96 * XTALMULT
	.word	64 * XTALMULT, 48 * XTALMULT, 32 * XTALMULT
	.word   24 * XTALMULT, 16 * XTALMULT, 12 * XTALMULT
	.word   6 * XTALMULT


	; -----------------------------------------
u_first	=*

u1_hw	.byt 0			; if bit 7 set, then hw is ready
u1_st	.byt 0			; if bit 7 set, then rx, bit 6 set then tx
u1_hs	.byt 0			; if bit 7 set, then rts/cts handshake

				; read and write pointer indexes into 
				; transfer buffers
u1_txwp	.byt 0			; tx, write from OS
u1_txrp	.byt 0			; tx, read from int
u1_rxwp	.byt 0			; rx write from int
u1_rxrp	.byt 0			; rx, read from OS

				; pad structure so that attributes
				; can be accessed with UARTDIFF index
	.dsb u1_hw+UARTDIFF-*, 0	 

u2_hw	.byt 0			; if bit 7 set then hw is ready
u2_st	.byt 0			; if bit 7 set, then rx, bit 6 set then tx
u2_hs	.byt 0			; if bit 7 set, then rts/cts handshake

				; read and write pointer indexes into 
				; transfer buffers
u2_txwp	.byt 0			; tx, write from OS
u2_txrp	.byt 0			; tx, read from int
u2_rxwp	.byt 0			; rx write from int
u2_rxrp	.byt 0			; rx, read from OS

u_last	=*			; end pointer for fill
u_len	=u_last-u_first

u1_rxbuf	.dsb 256
u1_txbuf	.dsb 256
u2_rxbuf	.dsb 256
u2_txbuf	.dsb 256

	.)

#endif
